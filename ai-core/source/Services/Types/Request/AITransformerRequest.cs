using System;
using System.Collections.Generic;
using AICore.Infrastructure.NoSpoonAI.Types.Data;
using AICore.Services.Types.Data;
using JetBrains.Annotations;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Schema;
using Newtonsoft.Json.Schema.Generation;
using UnityEngine.Serialization;

namespace AICore.Services.Types.Request
{
    /// <summary>
    /// Represents a request for the generative pre-trained transformers model.
    /// This request includes the sequence of messages, list of possible functions to call, and parameters such as model, tokens, temperature, and penalties.
    /// </summary>
    [Serializable]
    public class AITransformerRequest
    {
        /// <summary>
        /// The list of messages which forms the conversation. Each message has a role ("system", "user", or "assistant") and content.
        /// </summary>
        public List<DataMessage> messages;
        
        /// <summary>
        /// The list of possible functions that can be called during the conversation, based on the interaction.
        /// </summary>
        public List<Tool> tools;
        
        /// <summary>
        /// Represents the function calls. This could be a specific function name or "auto" for allowing the model to decide on its own.
        /// </summary>
        public object tool_choice;
        
        /// <summary>
        /// The maximum number of tokens that can be generated by the model. 
        /// </summary>
        public int max_tokens = 2048;
        
        /// <summary>
        /// Controls randomness. A higher value means the model's output is more random, while a lower value makes the model's output more deterministic.
        /// </summary>
        public float temperature = 1.0f;
        
        /// <summary>
        /// Used when applying the nucleus sampling strategy. A higher value increases randomness while a smaller value makes the output more deterministic.
        /// </summary>
        public float top_p = 1.0f;
        
        /// <summary>
        /// Number of independent completions to generate from the initial state. 
        /// </summary>
        public int n = 1;
        
        /// <summary>
        /// Whether to stream back the output as chunks of text are ready. If False, the output is provided all at once when complete.
        /// </summary>
        public bool stream = false;
        
        /// <summary>
        /// Penalty for new tokens based on their presence in the conversation so far. High values make new content less likely.
        /// </summary>
        public float presence_penalty = 0.0f;
        
        /// <summary>
        /// Penalty for new tokens based on their frequency in the conversation so far. High values make frequent tokens less likely.
        /// </summary>
        public float frequency_penalty = 0.0f;
        
        /// <summary>
        /// Contains context-specific variables for the conversation, such as the user's name.
        /// </summary>
        public string user = "";
        
        /// <summary>
        /// The AI model to use for processing the request.
        /// </summary>
        public AIModel model = AIModel.gpt;
        
        /// <summary>
        /// Represents the current token cost of the conversation. This value is used for tracking and management purposes.
        /// </summary>
        [FormerlySerializedAs("current_cost")] 
        public long current_token_cost = 0;
        
        public ResponseFormat response_format = new ResponseFormat();

        public AITransformerRequest() => messages = new List<DataMessage>();

        public AITransformerRequest(List<DataMessage> Messages, int MaxTokens, int Temperature, int TopP, int N, bool Stream, int PresencePenalty, int FrequencyPenalty, string User)
        {
            max_tokens = MaxTokens;
            temperature = Temperature;
            top_p = TopP;
            n = N;
            stream = Stream;
            presence_penalty = PresencePenalty;
            frequency_penalty = FrequencyPenalty;
            user = User;
            messages = Messages ?? new List<DataMessage>();
        }
    }

    /// <summary>
    /// Represents a single message in the conversation. This can be a message from the system, user, or assistant. It may also include a function call.
    /// </summary>
    [Serializable]
    public class DataMessage
    {
        /// <summary>
        /// The role of the entity sending the message - can be "system", "user", or "assistant".
        /// </summary>
        public AIRole role;

        /// <summary>
        /// The content of the message.
        /// </summary>
        public string content;

        public string name;

        /// <summary>
        /// The possible function call associated with this message.
        /// </summary>
        public List<ToolChoice> tool_calls = null;

        [CanBeNull] public string tool_call_id = null;
    }

    /// <summary>
    /// Details of a function call including its name and arguments.
    /// </summary>
    [Serializable]
    public class ToolChoice
    {
        public string id;
        public string type = "function";
        public FunctionToolChoice function;
    }

    /// <summary>
    /// A function that can be called during the conversation, its description, and details about its parameters.
    /// </summary>
    [Serializable]
    public class Tool
    {
        public string type = "function";
        public FunctionTool function;
    }

    [Serializable]
    public class FunctionTool
    {
        public string description;
        public string name;
        public FunctionToolParameter parameters;
    }
    
    [Serializable]
    public class FunctionToolChoice
    {
        public string name;
        public string arguments;
    }

    /// <summary>
    /// Documents the parameters a function accepts, including their type and required status.
    /// </summary>
    [Serializable]
    public class FunctionToolParameter
    {
        /// <summary>
        /// The data type of the parameters.
        /// </summary>
        public string type;

        /// <summary>
        /// A list of the required parameters.
        /// </summary>
        public List<string> required;

        /// <summary>
        /// Object capturing details about the properties of the parameters.
        /// </summary>
        public object properties;
    }

    [Serializable]
    public class ResponseFormat
    {
        public string type = "text";
        [CanBeNull] public object json_schema = null;
        
        public void SetTypeText() => type = "text";
        public void SetTypeJson() => type = "json_object";

        public void SetTypeStructuredOutput<T>(List<string> requiredProperties = null)
        {
            type = "json_schema";
            var generator = new JSchemaGenerator();
            var schema = generator.Generate(typeof(T));
            if (schema.Type == JSchemaType.Object)
            {
                requiredProperties?.ForEach(it =>
                {
                    if (schema.Properties.ContainsKey(it))
                    {
                        schema.Required.Add(it);
                    }
                    else
                    {
                        Console.WriteLine($"The property '{it}' does not exist in the object.");
                    }
                });
            }
            else
            {
                Console.WriteLine("The schema is not an object.");
            }

            var jsonSchemaObject = new JObject()
            {
                new JProperty("name", typeof(T).Name.Split('`')[0]),
                new JProperty("schema", JObject.FromObject(schema))
            };
            json_schema = jsonSchemaObject;
        }
    }
}